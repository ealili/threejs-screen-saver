<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <title>Three.js Rain</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  </head>
  <body>
    <div id="webgl-output">
      <div class="clock">
        <div class="hours">
          <div class="first">
            <div class="number">0</div>
          </div>
          <div class="second">
            <div class="number">0</div>
          </div>
        </div>
        <div class="tick">:</div>
        <div class="minutes">
          <div class="first">
            <div class="number">0</div>
          </div>
          <div class="second">
            <div class="number">0</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // necessary variables
      let scene,
        camera,
        renderer,
        cloudParticles = [],
        flash,
        rain,
        rainGeo,
        rainCount = 2000;
      function init() {
        // creating the scene
        scene = new THREE.Scene();
        // creating a perspective camera
        camera = new THREE.PerspectiveCamera(
          75, // Camera frustum vertical field of view.
          window.innerWidth / window.innerHeight, // Camera frustum aspect ratio.
          1, // Camera frustum near plane.
          1000 // Camera frustum far plane.
        );

        // Camera rotation
        camera.rotation.x = 0.8;
        camera.rotation.y = -0.12;
        camera.rotation.z = 0.27;

        // Adding lights

        // Ambient light which illuminates all objects in the scene from all directions
        ambient = new THREE.AmbientLight(0x555555);
        scene.add(ambient);

        // Directional light which will represent the moon light in the sky.
        directionalLight = new THREE.DirectionalLight(0xffeedd);
        directionalLight.position.set(0, 0, 1);
        scene.add(directionalLight);

        // Point light that gets emitted from a single point in all directions.
        flash = new THREE.PointLight(0x062d89, 30, 500, 1.7);
        flash.position.set(200, 300, 100);
        scene.add(flash);

        // set up renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        // FogExp2 contains the parameters that define exponential squared fog
        scene.fog = new THREE.FogExp2(0x11111f, 0.002);
        renderer.setClearColor(scene.fog.color);
        renderer.setSize(window.innerWidth, window.innerHeight);

        $("#webgl-output").append(renderer.domElement);

        rainGeo = new THREE.Geometry();
        for (let i = 0; i < rainCount; i++) {
          rainDrop = new THREE.Vector3(
            Math.random() * 400 - 200,
            Math.random() * 500 - 250,
            Math.random() * 400 - 200
          );
          rainDrop.velocity = {};
          rainDrop.velocity = 0;
          rainGeo.vertices.push(rainDrop);
        }

        rainMaterial = new THREE.PointsMaterial({
          color: 0xaaaaaa,
          size: 0.1,
          transparent: true,
        });
        rain = new THREE.Points(rainGeo, rainMaterial);
        scene.add(rain);

        // For the cloud I will use the cloud.png file as a texture
        let loader = new THREE.TextureLoader();
        loader.load("cloud.png", function (texture) {
          cloudGeo = new THREE.PlaneBufferGeometry(400, 400);
          cloudMaterial = new THREE.MeshLambertMaterial({
            map: texture,
            transparent: true,
          });

          // Add cloud
          for (let p = 0; p < 100; p++) {
            let cloud = new THREE.Mesh(cloudGeo, cloudMaterial);
            // Positioning the cloud randomly, setting rotation and adding to scene
            cloud.position.set(
              Math.random() * 800 - 400,
              400,
              Math.random() * 500 - 450
            );
            cloud.rotation.x = 0.8;
            cloud.rotation.y = -0.12;
            cloud.rotation.z = Math.random() * 360;
            cloud.material.opacity = 0.6;
            cloudParticles.push(cloud); // push to array for animation and rotation use
            scene.add(cloud);
          }
          animate();

          // Resize when changing the browser size
          window.addEventListener("resize", onResize, false);
          function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          }
          // document.addEventListener("keydown", onDocumentKeyDown, false);
          // function onDocumentKeyDown(event) {
          //   var keyCode = event.which;
          //   if (keyCode == 40) {
          //     rainCount -= 100;
          //     console.log("pressed");
          //   }
          //   if (keyCode == 38) {
          //     rainCount += 100;
          //   }
          // }
        });
      }
      function animate() {
        // rotate clouds one by one
        cloudParticles.forEach((p) => {
          p.rotation.z -= 0.0007;
        });
        rainGeo.vertices.forEach((p) => {
          p.velocity -= 0.1 + Math.random() * 0.1;
          p.y += p.velocity;
          if (p.y < -200) {
            p.y = 200;
            p.velocity = 0;
          }
        });
        rainGeo.verticesNeedUpdate = true;
        // rain.rotation.y += 0.002;
        if (Math.random() > 0.93 || flash.power > 100) {
          if (flash.power < 100)
            flash.position.set(
              Math.random() * 400,
              300 + Math.random() * 200,
              100
            );
          flash.power = 50 + Math.random() * 300;
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      init();
    </script>
    <script src="./clock.js"></script>
  </body>
</html>
